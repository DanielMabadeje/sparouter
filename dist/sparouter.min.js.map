{"version":3,"sources":["sparouter.js"],"names":["_helpers","require","SPARouter","options","_classCallCheck","this","routes","path","_requestPath","_var","variableChecker","mergedOptions","_objectSpread","caseInsensitive","historyMode","key","concat","_checkHistoryMode","uri","callback","thisArg","isSet","ArgNotFound","isString","ArgTypeError","isFunction","route","undefined","parameters","regExp","name","current","_caseInsensitive","toLowerCase","startsWith","forEach","_proccessParameters","push","length","Error","replace","parameterFound","parameter","index","targetRoute","_this","_proccessRegExp","found","routerObj","pathFor","goTo","url","data","title","_goTo","_historyMode","some","match","request","param","_processRequestParameters","window","location","pathname","call","_notFoundFunction","oldUrl","newUrl","arguments","isEmpty","TypeError","history","pushState","init","localStorage","setItem","href","_this2","string","nameFound","isObject","array","_iteratorNormalCompletion","_didIteratorError","_iteratorError","_step","_iterator","Symbol","iterator","next","done","value","err","Object","getOwnPropertyNames","includes","r","RegExp","_containsParameter","sn","parameterName","obj","i","search","_this3"],"mappings":"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","file":"sparouter.min.js","sourcesContent":["import {\r\n    variableChecker, ArgumentNotFoundError as ArgNotFound, ArgumentTypeError as ArgTypeError\r\n} from \"./helpers\";\r\n\r\n/**\r\n * @class SPARouter\r\n */\r\nclass SPARouter {\r\n\r\n     /**\r\n     * Instantiates the SPARouter Class.\r\n     * @param {Object} options\r\n     * @param {boolean} [options.caseInsensitive=true] - if set to false, uri matching will be case sensitive.\r\n     * @param {boolean} [options.historyMode=false] - Set to true if your application uses HTML History Mode Api.  \r\n     * If set to historyMode, SPARouter will handle popstate events by initializing the router again to update the page\r\n     * according to the callback function set with ``SPARouter.get()`` method.\r\n     * @example\r\n     * router = new SPARouter({\r\n     * historyMode: true,\r\n     * caseInsensitive: false\r\n     * });\r\n     */\r\n    constructor(options){\r\n        this.routes = [];\r\n        this.path =  this._requestPath();\r\n        this._var = variableChecker;\r\n\r\n        //default options\r\n        let defOptions = {\r\n            caseInsensitive: true,\r\n            historyMode: false\r\n        };\r\n        let mergedOptions = {...defOptions, ...options};\r\n        for(let key in mergedOptions){\r\n            this[`_${key}`] = mergedOptions[key];\r\n        }\r\n        this._checkHistoryMode();\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * The get method is used in assigning routes to your application\r\n     * @param {string | RegExp} uri route to be matched\r\n     * @param {callback} callback a callback function to be invoked if the route has been matched.\r\n     * @param {object} [thisArg=undefined] an argument that represents ``this`` keyword in your callback function. If empty, you will get undefined\r\n     * if you try to use ``this`` keyword in your callback function.  \r\n     * You can't pass the SPARouter class as ``this`` argument as it will return undefined also. The SPARouter class is already provided in the callback function\r\n     * @example\r\n     * // using a callback function\r\n     * SPARouter.get(\"/some-page-name\", (req, router)=>{\r\n     *      console.log(this.argument); // outputs \"A stored argument from my callback function\" to the console\r\n     *      console.log(req.url); // outputs \"/some-page-name\" to the console\r\n     * }, {argument: \"A stored argument from my callback function\"}); // this ouputs \"a stored argument from my callback function\" to the console.\r\n     * \r\n     * // using a class method\r\n     * class SomeClass {\r\n     *      constructor(){\r\n     *          this.argument = \"A stored argument from my class\";\r\n     *      }\r\n     *      pageFunction(req, router){\r\n     *          console.log(this.argument); // outputs \"A stored argument from my class\" to the console\r\n     *          console.log(req.url); // outputs \"/some-page-name\" to the console\r\n     *      }\r\n     * }\r\n     * myClass = new SomeClass();\r\n     * SPARouter.get(\"/some-page-name\", myClass.pageFunc, myClass);\r\n     */\r\n    \r\n    /**\r\n     * @callback callback\r\n     * @param {request} request\r\n     * @param {router} router\r\n     */\r\n\r\n     /**\r\n      * @typedef {Object} request\r\n      * @property {Object} param an object of parameters and their value.\r\n      * @property {string} uri the current request uri\r\n      */\r\n\r\n     /**\r\n      * @typedef {Object} router\r\n      * @property {pathFor} pathFor\r\n      * @property {goTo} goTo\r\n      * @property {boolean} historyMode check if history mode is set\r\n      */\r\n    \r\n    /**\r\n     * Returns the uri path for a named route.  \r\n     * If the route has parameters, an object of the parameter name as ``key`` and parameter value as ``value`` should be passed as second argument.\r\n     * @typedef {function} pathFor\r\n     * @memberof router\r\n     * @param {string} name The name of the route\r\n     * @param {Object} [parameter] An object of keys and values containing the parameters of the route and its corresponding value.\r\n     * @returns {string} uri\r\n     * @example\r\n     * var router = new SPARouter(options);\r\n     * router.get(\"/blog/{slug}\", function(req, router){\r\n     * console.log(router.pathFor(\"blog-post\", { slug: \"hello-world\"})) //outputs: /blog/hello-world\r\n     * }).setName(\"blog-post\");\r\n     */\r\n\r\n    /**\r\n     * Use this method if you would like to **go to** or **redirect** to a link.  \r\n     * This method uses window.location.href parsing the url param as the href.  \r\n     * If the historyMode method is set to true, it utilizes the history.pushState() passing\r\n     * the params and reinitializing the router.\r\n     * @typedef {function} goTo\r\n     * @memberof router\r\n     * @param {string} url The url you wish to goto. An absolute url is also acceptable so long it's of the same origin.\r\n     * @param {Object} [data={}] an object of data for HTML history.pushState()\r\n     * @param {string} [title=\"\"] title for HTML history.pushState()\r\n     */\r\n    get(uri, callback, thisArg){\r\n        if(!this._var.isSet(uri)) throw new ArgNotFound(\"uri\")\r\n        if(!this._var.isSet(callback)) throw new ArgNotFound(\"callback\");\r\n\r\n        if(!this._var.isString(uri)) throw new ArgTypeError(\"uri\", \"string\", uri);\r\n        if(!this._var.isFunction(callback)) throw new ArgTypeError(\"callback\", \"function\", callback);\r\n\r\n        thisArg = thisArg instanceof SPARouter ? undefined : thisArg;\r\n\r\n        let route = {\r\n            uri: null,\r\n            callback: null,\r\n            thisArg: thisArg,\r\n            parameters: null,\r\n            regExp: null,\r\n            name: null,\r\n            current: false\r\n        }\r\n\r\n        if(this._caseInsensitive) {\r\n            uri = uri.toLowerCase()\r\n        };\r\n        uri = uri.startsWith(\"/\") ? uri : `/${uri}`;\r\n        this.routes.forEach(route=>{\r\n            if(route.uri === uri) throw new Error(`Conflicting routes. The route uri ${route.uri} already exists`);\r\n        });\r\n\r\n        route.uri = uri;\r\n        route.callback = callback;\r\n        route.parameters = this._proccessParameters(route.uri);\r\n\r\n        this.routes.push(route);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Match the uri route where a parameter name matches a regular expression. This method must be chained to the\r\n     * ``SPARouter.get()`` method.\r\n     * @param {string} name parameter name to match\r\n     * @param {string} regExp regular expression pattern but must be in string format, without front slashes that converts\r\n     * it to a regExp object. E.g \"0-9\", \"[A-Z]\". See example below  \r\n     * Special characters which you wish to escape with the backslash must be double escaped. E.g \"\\\\\\w\" instead of \"\\w\";\r\n     * @example\r\n     * router.get(\"/{page-name}/{id}\",function(req, router){\r\n     * //do something with this route\r\n     * \r\n     * \r\n     * }).where(\"page-name\",\"user\").where(\"id\",\"[0-9]+\");\r\n     * //this route will match my-site.com/user/10, my-site.com/user/15\r\n     * // it won't match my-site.com/admin/10, my-site.com/user/login\r\n     */\r\n    where(name, regExp){\r\n        \r\n        //validate type\r\n        if(!this._var.isSet(name)) throw new ArgNotFound(\"name\");\r\n        if(!this._var.isSet(regExp)) throw new ArgNotFound(\"regExp\");\r\n        if(!this._var.isString(name)) throw new ArgTypeError(\"name\", \"string\", name);\r\n        if(!this._var.isString(regExp)) throw new ArgTypeError(\"regExp\", \"string\", regExp);\r\n\r\n        let route = this.routes[this.routes.length - 1]; // the target route\r\n        \r\n        //if paramaters exists for this route\r\n        if (route.parameters.length === 0) throw new Error(`No Parameters Found: Could not set paramater regExpression for [${route.uri}] because the route has no parameters`);\r\n        \r\n        regExp = regExp.replace(/\\(/g,\"\\\\(\");\r\n        regExp = regExp.replace(/\\)/g,\"\\\\)\");\r\n\r\n        regExp = `(${regExp}+)`;\r\n\r\n        let parameterFound = false;\r\n        route.parameters.forEach((parameter, index)=>{\r\n            if(parameter[name] !== undefined){\r\n                parameterFound = true;\r\n                parameter[name].regExp = regExp;\r\n            }\r\n        });\r\n \r\n        if(!parameterFound) throw new Error(`Invalid Parameter: Could not set paramater regExpression for [${route.uri}] because the parameter [${name}] does not exist`);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * SPARouter supports named routes. This methods sets the name of a route and can be referrenced using the\r\n     * `router.pathFor(name)` inside your callback function in `SPARouter.get()` method.  \r\n     * This method must be chained to the `SPARouter.get()` method.\r\n     * @param {string} name route name\r\n     * @example\r\n     * router = new SPARouter(options)\r\n     * router.get(\"/user/login\", function(req, router){\r\n     * // some functions here\r\n     * \r\n     * \r\n     * }).setName(\"user-login\");\r\n     * \r\n     * router.get(\"/user/home\", function(req, router){\r\n     * console.log(router.pathFor(\"user-home\")) // outputs: /user/home\r\n     * console.log(router.pathFor(\"user-login\")) // outputs: /user/login\r\n     * \r\n     * }).setName(\"user-home\")\r\n     */\r\n    setName(name){\r\n        if(!this._var.isSet(name)) throw new ArgNotFound(\"name\");\r\n        if(!this._var.isString(name)) throw new ArgTypeError(\"name\", \"string\", name);\r\n\r\n        let targetRoute = this.routes[this.routes.length - 1];\r\n        this.routes.forEach((route)=>{\r\n            if(route.name === name) throw new Error(`Duplicate naming. A route with name ${name} already exists`);\r\n        })\r\n        targetRoute.name = name;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Initialize the Router.  \r\n     * Call this method after setting up all route paths.\r\n     * @example\r\n     * const router = new SPARouter(myOptions);\r\n     * router.get(\"/\", homeCallback);\r\n     * router.get(\"/about\", aboutCallback).setName(\"about\");\r\n     * router.get(\"/contact\", contactCallback).setName(\"contact\");\r\n     * router.notFoundHandler(myNotFoundHandler);\r\n     * router.init();\r\n     */\r\n    init(){\r\n        this.routes.forEach((route)=>{\r\n            this._proccessRegExp(route);\r\n        }, this);\r\n\r\n        let found = false;\r\n        let routerObj = {\r\n            pathFor: (name, parameter)=>{\r\n                return this.pathFor(name, parameter);\r\n            },\r\n\r\n            goTo: (url, data, title)=>{\r\n                return this._goTo(url, data, title);\r\n            },\r\n\r\n            historyMode: this._historyMode\r\n        };\r\n        this.routes.some((route)=>{\r\n            if(this._requestPath().match(route.regExp)) {\r\n                route.current = true;\r\n                found = true;\r\n\r\n                let request = {};\r\n                request.param = this._processRequestParameters(route);\r\n                request.uri = window.location.pathname;\r\n\r\n                return route.callback.call(route.thisArg, request, routerObj);\r\n            }\r\n        },this)\r\n\r\n        if(!found){\r\n            if(!this._notFoundFunction) return;\r\n            let request = {};\r\n            request.uri = window.location.pathname;\r\n            return this._notFoundFunction(request, routerObj);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * A callback handler to execute if no route is matched.\r\n     * @param {function} callback Callback function\r\n     * @example\r\n     * router.notFoundHandler(function(){\r\n     * console.log(\"page not found\");\r\n     * // or redirect to the 404 page\r\n     * // or do anything you want!\r\n     * });\r\n     */\r\n    notFoundHandler(callback){\r\n        if(!this._var.isSet(callback)) throw new ArgNotFound(\"callback\");\r\n        if(!this._var.isFunction(callback)) throw new ArgTypeError(\"callback\", \"function\", callback);\r\n\r\n        this._notFoundFunction = callback;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Redirect one url to another\r\n     * @private\r\n     * @todo create api for redirecting routes\r\n     */\r\n    redirect(oldUrl, newUrl){\r\n        /*if(this._caseInsensitive){\r\n            oldUrl = oldUrl.toLowerCase();\r\n            newUrl = newUrl.toLowerCase();\r\n        }\r\n\r\n        if(oldUrl === newUrl) throw new Error(\"Redirect loop found as both urls are the same\");\r\n\r\n        if(typeof oldUrl === \"string\"){\r\n            this._getParameters(oldUrl, (params, newRoute)=>{\r\n                oldUrl = newRoute;\r\n            });\r\n        }\r\n\r\n        if (this._requestPath().match(`${oldUrl}$`)){\r\n            return window.location.href= newUrl;\r\n        }*/\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Route grouping\r\n     * @todo create api for grouping routes\r\n     * @private\r\n     */\r\n    group(){\r\n\r\n    }\r\n\r\n    _goTo(url, data = {}, title =\"\"){\r\n        if(!this._var.isSet(url) || !this._var.isString(url)) throw new ArgTypeError(\"url\", \"string\", url);\r\n        if(this._var.isEmpty(url)) throw new TypeError(\"url cannot be empty\");\r\n\r\n        if(!this._historyMode){\r\n            let storage = window.localStorage;\r\n            storage.setItem(\"pushState\", data);\r\n            return window.location.href= url;\r\n        }\r\n\r\n        window.history.pushState(data, title, url);\r\n        return this.init();\r\n    }\r\n\r\n    _pathFor(name, parameters = {}){\r\n\r\n        if(!this._var.isSet(name) || !this._var.isString(name)) throw new ArgTypeError(\"name\", \"string\", string);\r\n        let nameFound = false;\r\n        let uri;\r\n        this.routes.some(route=>{\r\n            if(route.name === name){\r\n                nameFound = true;\r\n                uri = route.uri;\r\n                if(this._containsParameter(uri)){\r\n                    \r\n                    if(!this._var.isSet(parameters) || !this._var.isObject(parameters)) throw new ArgTypeError(\"parameters\", \"object\", parameters);\r\n                    let array  = [];\r\n                    for(let value of route.uri.match(/\\{(\\w+)\\}/g)){\r\n                        value = value.replace(\"{\",\"\");\r\n                        value = value.replace(\"}\",\"\");\r\n                        array.push(value);\r\n                    }\r\n                    if(array.length !== Object.getOwnPropertyNames(parameters).length) throw new Error(`The route with name [${name}] contains ${array.length} parameters. ${Object.getOwnPropertyNames(parameters).length} given`)\r\n                    for(let parameter in parameters){\r\n                        if (!array.includes(parameter)) throw new Error(`Invalid parameter name [${parameter}]`);\r\n                        let r = new RegExp(`{${parameter}}`,\"g\");\r\n                        uri = uri.replace(r, parameters[parameter]);\r\n                    }\r\n                }\r\n            }\r\n        });\r\n        if (!nameFound) throw new Error(`Invalid route name [${name}]`);\r\n        return uri;\r\n    }\r\n\r\n    _proccessParameters(uri){\r\n        let parameters = [];\r\n        let sn = 0;\r\n\r\n        if(this._containsParameter(uri)){\r\n            uri.replace(/\\{\\w+\\}/g,(parameter)=>{\r\n                sn++;\r\n                parameter.replace(/\\w+/, (parameterName)=>{\r\n                    let obj = {};\r\n                    obj[parameterName] = {\r\n                        sn: sn,\r\n                        regExp: \"(\\\\w+)\",\r\n                        value: null\r\n                    }\r\n                    parameters.push(obj);\r\n                });\r\n            });\r\n        }\r\n        \r\n        return parameters;\r\n    }\r\n\r\n    _proccessRegExp(route){\r\n        let regExp = route.uri;\r\n\r\n        // escape special characters\r\n        regExp = regExp.replace(/\\//g, \"\\\\/\");\r\n        regExp = regExp.replace(/\\./g, \"\\\\.\");\r\n        regExp = regExp.replace(\"/\", \"/?\");\r\n\r\n        if(this._containsParameter(route.uri)){\r\n\r\n            //replace uri parameters with their regular expression\r\n            regExp.replace(/{\\w+}/g, (parameter)=>{\r\n                let parameterName = parameter.replace(\"{\",\"\");\r\n                parameterName = parameterName.replace(\"}\",\"\");\r\n                route.parameters.some((i)=>{\r\n                    if(i[parameterName] !== undefined) {\r\n                        regExp = regExp.replace(parameter, i[parameterName].regExp)\r\n                        return regExp;\r\n                    }\r\n                });\r\n                return parameter;\r\n            });\r\n        }\r\n        regExp = `^${regExp}$`;\r\n        route.regExp = new RegExp(regExp);\r\n        return route;\r\n    }\r\n\r\n    _containsParameter(uri){\r\n        return uri.search(/{\\w+}/g) >= 0;\r\n    }\r\n\r\n    _processRequestParameters(route){\r\n        let routeMatched = this._requestPath().match(route.regExp);\r\n        if (!routeMatched) return;\r\n        let param = {};\r\n        routeMatched.forEach((value, index)=>{\r\n            if(index !== 0){\r\n                let key = Object.getOwnPropertyNames(route.parameters[index - 1]);\r\n                param[key] = value;\r\n            }\r\n        });\r\n        return param;\r\n    }\r\n\r\n    _requestPath(){\r\n        return window.location.pathname;\r\n    }\r\n\r\n    _checkHistoryMode(){\r\n        if(!this._historyMode) return;\r\n\r\n        if(!window.PopStateEvent && !\"pushState\" in history) return; // check for support of popstate event and pushstate in browser\r\n\r\n        window.addEventListener(\"popstate\", (e)=>{\r\n            this.init();\r\n        });\r\n\r\n        return this;\r\n    }\r\n}\r\nexport default SPARouter;"]}